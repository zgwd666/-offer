#https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/
'''
解题思路：
设s的长度为n，p的长度为m；将s 的第i个字符记为si,p的第j个字符记为pl，将s的前i个字符组成的子字符串记为s[:i]，同理将p的前j个字符组成的子字符串记为p[:j].因此，本题可以转换为求解s[:n]和p[:m]是否匹配

整体思路是从s[:1]与j[:1]是否匹配开始判断，每轮新增一个字符并判断是否匹配，直到添加完整的字符串s和p。展开来看，假设s[:i]和p[:j]匹配，则下一个状态存在两种：

- 添加一个字符si+1后能够匹配
- 添加一个字符pj+1后能否匹配

因此本题的状态共有m*n种，应该定义状态矩阵dp,$$dp[i][j]代表了s[:i]和p[:j]是否可以匹配$$

1.dp数组以及下标的含义

$$dp[i][j]代表字符串s的前i个字符和p的前j个字符是否匹配$$

2.递推公式

需要注意，因为$$dp[0][0]$$代表空字符的状态，因此$$dp[i][j]$$对应的 添加字符是$$s[i-1]$$和$$p[j-1]$$

1. 当p[j-1]='*'时，$$dp[i][j]$$在当以下任一情况为true的时等于true
   - $$dp[i][j-2]$$:即将字符组合dp[j-2]*看作出现0次时，能否匹配
   - $$dp[i-1][j] 且s[i-1]=p[j-2]:即让字符p[j-2]多出现一次时，能否匹配$$
   - $$dp[i-1][j] 且p[j-2]='.':即让字符'.'多出现一次时，能否匹配$$
2. 当p[j-1]!='*'时，$$dp[i][j]在当以下任一情况为true时等于true$$：
   - $$dp[i-1][j-1]且s[i-1]=p[j-1]：即看s[i-1]和p[j-1]是否匹配$$
   - $$dp[i-1][j-1]且p[j-1]=='.'：即将'.'看作为字符s[i-1]时是否匹配$$

3.初始化数组

$$dp[0][0]=True，代表两个字符串都为空时，可以进行匹配$$

$$dp[0][j]=dp[0][j-2]且p[j-1]='*':首行s为空字符串，因此当p的偶数位为*的时候才能匹配（即让p的奇数位出现0次，保持p是空字符串）因此，循环遍历字符串p，步长为2（即只看偶数位）$$

4.遍历顺序

从上到下，从左到右遍历

5.举例推导dp数组
'''
class Solution:
    def articleMatch(self, s: str, p: str) -> bool:
        dp=[[False for i in range(len(p)+1)]for i in range(len(s)+1)]#创建状态转移数组
        #初始化
        dp[0][0]=True
        for i in range(1,len(p)+1):
            if i%2==0 and p[i-1]=='*'and dp[0][i-2]:
                dp[0][i]=True
        for i in range(1,len(s)+1):#进行遍历
            for j in range(1,len(p)+1):
                #按照递推公式进行计算
                if p[j-1]=='*':
                  dp[i][j]=dp[i][j-2] or dp[i-1][j] and (s[i-1]==p[j-2] or p[j-2]=='.')
                else:
                    dp[i][j]=dp[i-1][j-1] and(s[i-1]==p[j-1] or p[j-1]=='.' )
        return dp[-1][-1]#返回结果
